---
title: Referenz zum Exploit-Schutz
keywords: Risikominderungen, Sicherheitsrisiken, Sicherheitsrisiken, Gegenmaßnahmen, Exploits, Exploits, emet
description: Details zur Funktionsweise des Exploitschutzfeatures in Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: a87215b0e23d56a73259bbee4600ec9e15a27f3b
ms.sourcegitcommit: dcb97fbfdae52960ae62b6faa707a05358193ed5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 03/25/2021
ms.locfileid: "51199345"
---
# <a name="exploit-protection-reference"></a>Exploit-Schutzreferenz

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Gilt für:**
- [Microsoft Defender für Endpunkt](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Möchten Sie Microsoft Defender for Endpoint erleben? [Registrieren Sie sich für eine kostenlose Testversion.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit-Schutz bietet erweiterte Schutzmöglichkeiten für Anwendungen, die von der IT-Pro angewendet werden können, nachdem der Entwickler die Software kompiliert und verteilt hat.

Dieser Artikel hilft Ihnen zu verstehen, wie Exploitschutz sowohl auf Richtlinienebene als auch auf der ebene der einzelnen Gegenmaßnahmen funktioniert, um Sie bei der erfolgreichen Erstellung und Anwendung von Exploit Protection-Richtlinien zu unterstützen.

## <a name="how-mitigations-are-applied"></a>Anwendung von Gegenmaßnahmen

Exploit Protection-Gegenmaßnahmen werden pro Anwendung angewendet.

Gegenmaßnahmen werden über einen Registrierungseintrag für jedes Programm konfiguriert, für das Sie Schutzmaßnahmen konfigurieren. Diese Einstellungen werden im **Registrierungseintrag MitigationOptions** für jedes Programm gespeichert (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Sie werden wirksam, wenn Sie das Programm neu starten und wirksam bleiben, bis Sie es ändern und das Programm erneut starten.

> [!IMPORTANT]
> Mit den Ausführungsoptionen für Bilddatei können Sie nur einen Dateinamen oder Pfad und keine Versionsnummer, Architektur oder einen anderen Differentiator angeben. Achten Sie darauf, Gegenmaßnahmen auf Apps mit eindeutigen Namen oder Pfaden zu verwenden, indem Sie sie nur auf Geräten anwenden, auf denen Sie diese Version und die Architektur der Anwendung getestet haben.

Wenn Sie Exploitschutzminderungen mithilfe einer XML-Konfigurationsdatei konfigurieren, entweder über PowerShell, Gruppenrichtlinie oder MDM, werden bei der Verarbeitung dieser XML-Konfigurationsdatei individuelle Registrierungseinstellungen für Sie konfiguriert.

Wenn die Richtlinie, die die XML-Datei verteilt, nicht mehr erzwungen wird, werden die von dieser XML-Konfigurationsdatei bereitgestellten Einstellungen nicht automatisch entfernt. Um Exploit Protection-Einstellungen zu entfernen, exportieren Sie die XML-Konfiguration von einem bereinigen Windows 10 Gerät, und stellen Sie diese neue XML-Datei zur Bereitstellung. Alternativ bietet Microsoft eine XML-Datei als Teil der Windows-Sicherheit Baselines zum Zurücksetzen von Exploit Protection-Einstellungen.

Zum Zurücksetzen von Exploitschutzeinstellungen mithilfe von PowerShell können Sie den folgenden Befehl verwenden:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Im Folgenden finden Sie EP-reset.xml, die mit den Windows-Sicherheit werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Referenz zur Risikominderung

In den folgenden Abschnitten werden die von den einzelnen Schutzmaßnahmen gegen Exploits bereitgestellten Schutzmaßnahmen, die Kompatibilitätsüberlegungen für die Gegenmaßnahmen und die verfügbaren Konfigurationsoptionen beschrieben.

## <a name="arbitrary-code-guard"></a>Beliebiger Code guard

### <a name="description"></a>Beschreibung

Beliebiger Codeschutz schützt vor böswilligen Angreifern, die den Code ihrer Wahl durch eine Speichersicherheitslücke in den Arbeitsspeicher laden und diesen Code ausführen können.

Arbitrary code guard schützt eine Anwendung vor der Ausführung dynamisch generierten Codes (Code, der nicht geladen wird, z. B. aus der exe selbst oder einer DLL). Beliebiger Codeschutz funktioniert, indem verhindert wird, dass der Arbeitsspeicher als ausführbare Datei markiert wird. Wenn eine Anwendung versucht, Arbeitsspeicher [zuzuordnen,](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)überprüfen wir die Schutzflags. (Speicher kann mit Schutzflags für Lese-, Schreib- und/oder Ausführungsschutz zugewiesen werden.) Wenn die Zuordnung versucht, [](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) das Flag für den Ausführungsschutz zu verwenden, schlägt die Speicherzuordnung fehl und gibt einen Fehlercode (STATUS_DYNAMIC_CODE_BLOCKED). Ebenso schlägt die Berechtigungsänderung [](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) fehl, wenn eine Anwendung versucht, die [](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) Schutzflags des bereits zugewiesenen Speichers zu ändern, der bereits zugewiesen wurde und das Execute Protection-Flag enthält, und gibt einen Fehlercode (STATUS_DYNAMIC_CODE_BLOCKED).

Indem verhindert  wird, dass das Ausführungsflag festgelegt wird, kann das Feature zur Verhinderung von Datenausführung von Windows 10 dann vor dem Anweisungszeiger schützen, der auf diesen Speicher festgelegt wird, und diesen Code ausführen.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Arbitrary Code Guard verhindert die Zuweisung von Arbeitsspeicher als ausführbare Datei, was ein Kompatibilitätsproblem mit Ansätzen wie Just-in-Time(JIT)-Compilern zur Verfügung stellt. Die meisten modernen Browser kompilieren beispielsweise JavaScript in systemeigenen Code, um die Leistung zu optimieren. Um diese Risikominderung zu unterstützen, müssen sie neu entwickelt werden, um die JIT-Kompilierung außerhalb des geschützten Prozesses zu verschieben. Andere Anwendungen, deren Entwurf dynamisch Code aus Skripts oder anderen Zwischensprachen generiert, sind ähnlich inkompatibel mit dieser Gegenmaßnahmen.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Thread-Opt-Out** zulassen – Sie können die Gegenmaßnahmen so konfigurieren, dass ein einzelner Thread diesen Schutz abmeldet. Der Entwickler muss die Anwendung im Bewusstsein dieser Gegenmaßnahmen geschrieben und die [**SetThreadInformation-API**](https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) aufgerufen haben, der *ThreadInformation-Parameter* ist auf **ThreadDynamicCodePolicy** festgelegt, um dynamischen Code in diesem Thread ausführen zu können.

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-low-integrity-images"></a>Blockieren von Bildern mit niedriger Integrität

### <a name="description"></a>Beschreibung

Bilder mit niedriger Integrität blockieren verhindert, dass die Anwendung Dateien lädt, die nicht vertrauenswürdig sind, in der Regel, weil sie aus einem Sandkastenbrowser aus dem Internet heruntergeladen wurden.

Diese Risikominderung blockiert Bildlasten, wenn das Bild über einen Zugriffssteuerungseintrag (Access Control Entry, ACE) verfügt, der Zugriff auf Low IL-Prozesse gewährt und kein Ace für die Vertrauensstellungsbezeichnung besitzt. Es wird vom Speicher-Manager implementiert, der die Datei an das Zugeordnete an den Arbeitsspeicher sperrt. Wenn eine Anwendung versucht, ein Image mit niedriger Integrität zu zuordnungen, löst sie einen Fehler STATUS_ACCESS_DENIED aus. Weitere Informationen zur Funktionsweise von Integritätsstufen finden Sie unter [Mandatory Integrity Control](https://docs.microsoft.com/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Bilder mit niedriger Integrität blockieren verhindern, dass die Anwendung Dateien lädt, die aus dem Internet heruntergeladen wurden. Wenn ihr Anwendungsworkflow das Laden heruntergeladener Bilder erfordert, sollten Sie sicherstellen, dass sie aus einem Prozess mit höherer Vertrauenswürdigkeit heruntergeladen werden oder explizit umetikettiert werden, um diese Risikominderung anzuwenden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-remote-images"></a>Blockieren von Remotebildern

### <a name="description"></a>Beschreibung

Das Blockieren von Remoteabbildern verhindert, dass die Anwendung Dateien lädt, die auf einem Remotegerät gehostet werden, z. B. einer UNC-Freigabe. Das Blockieren von Remotebildern schützt vor dem Laden von Binärdateien in den Arbeitsspeicher, die sich auf einem externen Gerät befinden, das vom Angreifer gesteuert wird.

Durch diese Risikominderung werden Bildlasten blockiert, wenn das Bild auf einem Remotegerät gespeichert ist. Es wird vom Speicher-Manager implementiert, der die Datei an das Zugeordnete an den Arbeitsspeicher sperrt. Wenn eine Anwendung versucht, eine Remotedatei zu zuordnungen, löst sie einen fehler STATUS_ACCESS_DENIED aus.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Remoteabbilder blockieren verhindert, dass die Anwendung Bilder von Remotegeräten lädt. Wenn Ihre Anwendung Dateien oder Plug-Ins von Remotegeräten lädt, ist sie nicht mit dieser Gegenmaßnahmen kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-untrusted-fonts"></a>Blockieren nicht vertrauenswürdiger Schriftarten

### <a name="description"></a>Beschreibung

Das Blockieren nicht vertrauenswürdiger Schriftarten verringert das Risiko eines Fehlers bei der Schriftartenparsierung, der dazu führt, dass der Angreifer Code auf dem Gerät ausführen kann. Nur Schriftarten, die im Verzeichnis windows\fonts installiert sind, werden zur Verarbeitung durch GDI geladen.

Diese Gegenmaßnahmen werden in GDI implementiert, wodurch der Speicherort der Datei überprüft wird. Wenn sich die Datei nicht im Verzeichnis der Systemschriftarten befindet, wird die Schriftart nicht zur Analyse geladen, und dieser Aufruf wird fehlschlagen.

Diese Gegenmaßnahmen sind zusätzlich zu der integrierten Gegenmaßnahmen in Windows 10 1607 und höher, die die Schriftartenparsierung aus dem Kernel und in einen App-Container im Benutzermodus verschiebt. Jeder Exploit, der auf der Schriftartenparsierung basiert, geschieht in einem sandkastenbasierten und isolierten Kontext, wodurch das Risiko erheblich reduziert wird. Weitere Informationen zu dieser Gegenmaßnahmen finden Sie im Blog Windows 10 mit [Zero-Day-Exploit-Gegenmaßnahmen](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die am häufigsten verwendeten Schriftarten außerhalb des Systemschriftartenverzeichnisses werden mit [Webschriftarten verwendet.](https://docs.microsoft.com/typography/fonts/font-faq#web) Moderne Browser, z. B. Microsoft Edge, verwenden DirectWrite anstelle von GDI und sind nicht betroffen. Ältere Browser wie Internet Explorer 11 (und der IE-Modus im neuen Microsoft Edge) können jedoch betroffen sein, insbesondere bei Anwendungen wie Office 365, die Schriftartglyphen zum Anzeigen der Benutzeroberfläche verwenden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="code-integrity-guard"></a>Codeintegritätsschutz

### <a name="description"></a>Beschreibung

Code Integrity Guard stellt sicher, dass alle in einen Prozess geladenen Binärdateien von Microsoft digital signiert werden. Code Integrity Guard enthält [WHQL-Signaturen](https://docs.microsoft.com/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), die es WHQL-genehmigten Treibern ermöglichen, innerhalb des Prozesses ausgeführt zu werden.

Diese Gegenmaßnahmen werden im Speicher-Manager implementiert, wodurch verhindert wird, dass die Binärdatei dem Arbeitsspeicher zugeordnet wird. Wenn Sie versuchen, eine Binärdatei zu laden, die nicht von Microsoft signiert ist, gibt die Speicher-Manger den Fehler STATUS_INVALID_IMAGE_HASH. Durch das Blockieren auf Speicher-Manager-Ebene wird verhindert, dass sowohl vom Prozess geladene Binärdateien als auch Binärdateien in den Prozess eingejiziert werden.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Risikominderung blockiert insbesondere binäre Dateien, die nicht von Microsoft signiert sind. Daher ist sie mit den meisten Drittanbietersoftware nicht kompatibel, es sei denn, diese Software wird von der Microsoft Store verteilt (und digital signiert), und die Option zum Laden von Bildern, die vom Microsoft Store signiert wurden, ist ausgewählt.

### <a name="configuration-options"></a>Konfigurationsoptionen

Auch das Laden von von **Microsoft Store** signierten Bildern zulassen – Anwendungen, die von der Microsoft Store verteilt werden, werden von der Microsoft Store digital signiert, und durch das Hinzufügen dieser Konfiguration können Binärdateien, die den Speicherzertifizierungsprozess durchgegangen sind, von der Anwendung geladen werden.

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="control-flow-guard-cfg"></a>Control Flow Guard (CFG)

### <a name="description"></a>Beschreibung

Control Flow Guard (CFG) verringert das Risiko, dass Angreifer Sicherheitslücken bei Speicherbeschädigungen nutzen, indem indirekte Funktionsaufrufe geschützt werden. Ein Angreifer kann z. B. eine Pufferüberlauf-Sicherheitslücke nutzen, um Arbeitsspeicher mit einem Funktionszeiger zu überschreiben und diesen Funktionszeiger durch einen Zeiger auf ausführbaren Code seiner Wahl zu ersetzen (der möglicherweise auch in das Programm eingeblendet wurde).

Diese Gegenmaßnahmen werden durch eine weitere Überprüfung zur Kompilierungszeit bereitgestellt. Vor jedem indirekten Funktionsaufruf werden weitere Anweisungen hinzugefügt, die sicherstellen, dass es sich bei dem Ziel um ein gültiges Anrufziel handelt, bevor es aufgerufen wird. Wenn das Ziel kein gültiges Anrufziel ist, wird die Anwendung beendet. Daher können nur Anwendungen, die mit CFG-Unterstützung kompiliert werden, von dieser Gegenmaßnahmen profitieren.

Die Überprüfung auf ein gültiges Ziel wird vom Windows bereitgestellt. Wenn ausführbare Dateien geladen werden, werden die Metadaten für indirekte Anrufziele zur Ladezeit extrahiert und als gültige Aufrufziele markiert. Wenn arbeitsspeicher zugewiesen und als ausführbare Datei markiert wird (z. B. für generierten Code), werden diese Speicherspeicherorte auch als gültige Aufrufziele gekennzeichnet, um Mechanismen wie die JIT-Kompilierung zu unterstützen.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Da Anwendungen zur Unterstützung von CFG kompiliert werden müssen, deklarieren sie implizit ihre Kompatibilität damit. Die meisten Anwendungen sollten daher mit dieser Gegenmaßnahmen aktiviert arbeiten. Da diese Prüfungen in die Binärdatei kompiliert werden, besteht die Konfiguration, die Sie anwenden können, lediglich in der Deaktivierung von Prüfungen innerhalb des Windows Kernels. Mit anderen Worten, die Gegenmaßnahmen sind standardmäßig aktiviert, Aber Sie können den Windows-Kernel so konfigurieren, dass er immer "Ja" zurück gibt, wenn Sie später feststellen, dass es ein Kompatibilitätsproblem gibt, das der Anwendungsentwickler in seinen Tests nicht festgestellt hat, was selten sein sollte.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Strikte CFG** verwenden : Im strengen Modus müssen alle in den Prozess geladenen Binärdateien für Control Flow Guard kompiliert werden (oder keinen ausführbaren Code enthalten , z. B. Ressourcen-DLLs), um geladen zu werden.

> [!Note]
> **Der Steuerelementflussschutz** verfügt über keinen Überwachungsmodus. Binärdateien werden kompiliert, wenn diese Gegenmaßnahmen aktiviert sind.

## <a name="data-execution-prevention-dep"></a>Data Execution Prevention (DEP)

### <a name="description"></a>Beschreibung

Die Verhinderung von Datenausführung (Data Execution Prevention, DEP) verhindert, dass Speicher ausgeführt wird, der nicht explizit als ausführbare Datei zugewiesen wurde. DEP schützt vor Angreifern, die bösartigen Code in den Prozess einwerfen, z. B. durch einen Pufferüberlauf, und führen diesen Code dann aus.

Wenn Sie versuchen, den Anweisungszeiger auf eine Speicheradresse zu setzen, die nicht als ausführbare Datei gekennzeichnet ist, wird vom Prozessor eine Ausnahme ausgelöst (Allgemeine Schutzverletzung), wodurch die Anwendung abstürzt.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Für alle ausführbaren x64-, ARM- und ARM-64-Ausführbaren Dateien ist standardmäßig die DEP aktiviert, und sie kann nicht deaktiviert werden. Da eine Anwendung nie ohne DEP ausgeführt wurde, wird die Kompatibilität vorausgesetzt.

Für alle x86-Binärdateien (32-Bit) ist DEP standardmäßig aktiviert, DEP kann jedoch pro Prozess deaktiviert werden. Einige ältere Anwendungen, in der Regel Anwendungen, die vor Windows XP SP2 entwickelt wurden, sind möglicherweise nicht mit DEP kompatibel. Solche Anwendungen generieren normalerweise dynamisch Code (z. B. JIT-Kompilierung) oder verknüpfen mit älteren Bibliotheken (z. B. älteren Versionen von ATL), die dynamisch Code generieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Aktivieren der ATL-Thunk-Emulation** – Diese Konfigurationsoption deaktiviert die ATL-Thunk-Emulation. ATL, die ActiveX Vorlagenbibliothek, ist so klein und schnell wie möglich konzipiert. Um die binäre Größe zu reduzieren, wird eine Technik namens *"Thunking" verwendet.* Thunking wird in der Regel für die Interaktion zwischen 32-Bit- und 16-Bit-Anwendungen verwendet, aber es gibt hier keine 16-Bit-Komponenten für ATL. Um die binäre Größe zu optimieren, speichern ATL stattdessen Computercode im Arbeitsspeicher, der nicht wortbündig ausgerichtet ist (wodurch eine kleinere Binärdatei erstellt wird), und ruft diesen Code dann direkt auf. ATL-Komponenten, die mit Visual Studio 7.1 oder früheren Versionen (Visual Studio 2003) kompiliert wurden, weisen diesen Speicher nicht als ausführbare Datei zu – die Thunkemulation löst dieses Kompatibilitätsproblem. Anwendungen mit einem binären Erweiterungsmodell (z. B. Internet Explorer 11) müssen häufig die ATL-Thunk-Emulation aktiviert haben.

## <a name="disable-extension-points"></a>Deaktivieren von Erweiterungspunkten

### <a name="description"></a>Beschreibung

Durch diese Risikominderung werden verschiedene Erweiterungspunkte für eine Anwendung deaktiviert, die zum Einrichten von Persistenz oder zum Erhöhen von Berechtigungen für schädliche Inhalte verwendet werden können.

Dies umfasst Folgendes:

- **AppInit DLLs** – Wenn ein Prozess gestartet wird, wird die angegebene DLL vom System in den Kontext des neu gestarteten Prozesses geladen, bevor die Einstiegspunktfunktion aufruft. [Details zu AppInit-DLLs finden Sie hier](https://docs.microsoft.com/windows/win32/winmsg/about-window-classes#application-global-classes). Wenn diese Gegenmaßnahmen angewendet werden, werden AppInit-DLLs nicht geladen. Ab Windows 7 müssen AppInit-DLLs digital signiert werden, wie [hier beschrieben.](https://docs.microsoft.com/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) Darüber hinaus werden Windows 8 AppInit-DLLs nicht geladen, wenn SecureBoot aktiviert ist, wie [hier beschrieben.](https://docs.microsoft.com/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **Legacy-IMEs** – Mit einem Eingabemethode-Editor (Input Method Editor, IME) kann ein Benutzer Text in einer Sprache eingeben, die mehr Zeichen als auf einer Tastatur dargestellt werden kann. Drittanbieter können IMEs erstellen. Ein bösartiger IME kann Anmeldeinformationen oder andere vertrauliche Informationen aus dieser Eingabeaufnahme abrufen. Einige IMEs, die als Legacy-IMEs bezeichnet werden, funktionieren nur für Windows Desktop-Apps und nicht für UWP-Apps. Durch diese Risikominderung wird außerdem verhindert, dass dieser legacy-IME in die angegebene Windows Desktop-App geladen wird.
- **Windows Ereignishaken** : Eine Anwendung kann die [SetWinEventHook-API aufrufen,](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook) um interesse an einem Ereignis zu registrieren, das stattfindet. Eine DLL wird angegeben und kann in den Prozess injiziert werden. Diese Gegenmaßnahmen erzwingt, dass der Hook in den Registrierungsprozess bereitgestellt wird, anstatt prozessin-prozess über eine injizierte DLL ausgeführt zu werden.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die meisten dieser Erweiterungspunkte werden relativ selten verwendet, sodass die Kompatibilitätsauswirkungen in der Regel gering sind, insbesondere auf einer einzelnen Anwendungsebene. Eine Überlegung ist, ob Benutzer Legacy-IMEs von Drittanbietern verwenden, die nicht mit der geschützten Anwendung funktionieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

Es gibt keine Konfigurationsoptionen für diese Gegenmaßnahmen.

> [!Note]
> **Erweiterungspunkte deaktivieren** weist keinen Überwachungsmodus auf.

## <a name="disable-win32k-system-calls"></a>Deaktivieren von Win32k-Systemanrufen

### <a name="description"></a>Beschreibung

Win32k.sys bietet eine breite Angriffsfläche für einen Angreifer. Als Kernelmoduskomponente wird sie häufig als Escapevektor für Sandkastenanwendungen verwendet. Diese Risikominderung verhindert Aufrufe win32k.sys, indem verhindert wird, dass sich ein Thread in einen GUI-Thread wandelt, der dann Zugriff auf Win32k-Funktionen hat. Ein Thread ist beim Erstellen nicht GUI, wird jedoch beim ersten Aufruf von win32k.sys oder über einen API-Aufruf von [IsGuiThread konvertiert.](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread)

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Gegenmaßnahmen sind für Prozesse konzipiert, bei der es sich um dedizierte Nicht-UI-Prozesse handelt. Viele moderne Browser verwenden z. B. die Prozessisolation und integrieren Nicht-UI-Prozesse. Jede Anwendung, die eine GUI mit einem einzelnen Prozess anzeigt, wird von dieser Gegenmaßnahmen betroffen sein.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="do-not-allow-child-processes"></a>Untergeordnete Prozesse nicht zulassen

### <a name="description"></a>Beschreibung

Diese Gegenmaßnahmen verhindern, dass eine Anwendung neue untergeordnete Anwendungen erstellt. Ein gängiges Verfahren, das von Gegnern verwendet wird, ist das Initiieren eines vertrauenswürdigen Prozesses auf dem Gerät mit böswilliger Eingabe (ein Angriff vom Land), der häufig das Starten einer anderen Anwendung auf dem Gerät erfordert. Wenn es keine legitimen Gründe gibt, warum eine Anwendung einen untergeordneten Prozess starten würde, wird dieser potenzielle Angriffsvektor durch diese Gegenmaßnahmen abgemildert. Die Gegenmaßnahmen werden durch Festlegen einer Eigenschaft für das Prozesstoken angewendet, das die Erstellung eines Tokens für den untergeordneten Prozess mit der Fehlermeldung STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Wenn Ihre Anwendung aus irgendeinem Grund untergeordnete Anwendungen startet, z. B. die Unterstützung von Hyperlinks, die einen Browser oder einen externen Browser starten, oder die andere Dienstprogramme auf dem Computer starten, wird diese Funktionalität durch diese Gegenmaßnahmen unterbrochen.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="export-address-filtering"></a>Filtern von Exportadressen

### <a name="description"></a>Beschreibung

Die Exportadressenfilterung (EAF) verringert das Risiko, dass schädlicher Code in der Exportadressentabelle aller geladenen Module nach Modulen sucht, die nützliche APIs für den Angriff enthalten. Dies ist eine gängige Taktik, die von shellcode verwendet wird. Um das Risiko eines solchen Angriffs zu mindern, schützt diese Risikominderung drei häufig angegriffene Module:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

Der Ausgleich schützt die Speicherseite im [Exportverzeichnis, das auf die [Exportadressentabelle verweist.](https://docs.microsoft.com/windows/win32/debug/pe-format#export-address-table) Auf diese Speicherseite wird [der PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) angewendet. Wenn jemand versucht, auf diesen Speicher zu zugreifen, generiert er eine STATUS_GUARD_PAGE_VIOLATION. Die Gegenmaßnahmen verarbeiten diese Ausnahme, und wenn die Zugriffsanweisung die Überprüfung nicht besteht, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Risikominderung ist in erster Linie ein Problem für Anwendungen wie Debugger, Sandkastenanwendungen, Anwendungen mit DRM oder Anwendungen, die Antidebuggertechnologie implementieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Überprüfen des Zugriffs** auf Module, die häufig von Exploits missbraucht werden – Diese Option, auch als EAF+ bekannt, bietet Schutz für andere häufig angegriffene Module:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Durch aktivieren von EAF+ fügt diese Gegenmaßnahmen außerdem den PAGE_GUARD-Schutz zu der Seite hinzu, die den "MZ"-Header enthält, die ersten beiden Bytes des [DOS-Headers in](https://docs.microsoft.com/windows/win32/debug/pe-format#ms-dos-stub-image-only)einer PE-Datei. Dies ist ein weiterer Aspekt bekannter Speicherinhalte, nach denen shellcode suchen kann, um Module zu identifizieren, die potenziell für den Arbeitsspeicher von Interesse sind.

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="force-randomization-for-images-mandatory-aslr"></a>Erzwingen der Randomisierung für Bilder (obligatorische ASLR)

### <a name="description"></a>Beschreibung

Die Randomisierung des Adressraumlayouts (Address Space Layout Randomization, ASLR) verringert das Risiko, dass ein Angreifer sein Wissen über das Speicherlayout des Systems verwendet, um Code auszuführen, der bereits im Prozessspeicher vorhanden ist und bereits als ausführbare Datei gekennzeichnet ist. Dies kann das Risiko eines Angreifers mithilfe von Techniken wie return-to-libc-Angriffen verringern, bei denen der Angreifer den Kontext legt und dann die Rückgabeadresse so ändert, dass vorhandener Code mit Kontext ausgeführt wird, der dem Zweck des Angreifers entspricht.

Die obligatorische ASLR erzwingt eine Erneute Basis aller DLLs innerhalb des Prozesses. Ein Entwickler kann ASLR mithilfe der [Linkeroption /DYNAMICBASE](https://docs.microsoft.com/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) aktivieren, und diese Risikominderung hat die gleiche Auswirkung.

Wenn der Speicher-Manager im Bild in den Prozess zuordnen wird, wird die obligatorische ASLR DLLs und EXEs, die sich nicht für ASLR entschieden haben, forciert. Beachten Sie jedoch, dass diese Neubasierung keine Entropie besitzt und daher an einem vorhersagbaren Speicherort im Arbeitsspeicher platziert werden kann. Für rebased und randomized location of binaries, this mitigation should be paired with [Randomize memory allocations (Bottom-up ASLR)](#randomize-memory-allocations-bottom-up-aslr).

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Kompatibilitätswirkung von ASLR ist in der Regel auf ältere Anwendungen beschränkt, die mithilfe von Compilern erstellt wurden, die Annahmen zur Basisadresse einer Binärdatei erstellt haben oder Basisverlagerungsinformationen entfernt haben. Dies kann zu unvorhersehbaren Fehlern führen, wenn der Ausführungsfluss versucht, zum erwarteten und nicht zum tatsächlichen Speicherort im Arbeitsspeicher zu springen.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Entfernte Bilder nicht** zulassen – Mit dieser Option wird das Laden von Bildern blockiert, deren Standortinformationen entfernt wurden. Das Windows#A0 enthält absolute Adressen, und der Compiler generiert auch eine [Basisverlagerungstabelle, mit der das Lademodul alle relativen Speicherverweise und deren Offset finden kann, sodass sie aktualisiert werden können, wenn die Binärdatei nicht an ihrer bevorzugten Basisadresse geladen wird. Einige ältere Anwendungen isolieren diese Informationen in Produktionsbuilds, und daher können diese Binärdateien nicht neubasiert werden. Durch diese Gegenmaßnahmen wird verhindert, dass solche Binärdateien geladen werden (anstatt sie an ihrer bevorzugten Basisadresse zu laden).

> [!Note]
> **Die Erzwingen der Randomisierung für Bilder (obligatorische ASLR)** verfügt über keinen Überwachungsmodus.

## <a name="import-address-filtering-iaf"></a>Import address filtering (IAF)

### <a name="description"></a>Beschreibung

Die Minderung der Importadressenfilterung (Import Address Filtering, IAF) trägt dazu bei, das Risiko zu mindern, dass ein Angreifer den Steuerungsfluss einer Anwendung ändert, indem die Importadressentabelle (Import Address Table, IAT) geändert wird, um zu beliebigem Code der Wahl des Angreifers umzuleiten, wenn diese Funktion aufgerufen wird. Ein Angreifer kann diesen Ansatz verwenden, um die Steuerung zu entführen oder Anrufe an vertrauliche APIs abzufangen, zu überprüfen und potenziell zu blockieren.

Auf die Speicherseiten für alle geschützten APIs wird der PAGE_GUARD [angewendet.](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) Wenn jemand versucht, auf diesen Speicher zu zugreifen, generiert er eine STATUS_GUARD_PAGE_VIOLATION. Die Gegenmaßnahmen verarbeiten diese Ausnahme, und wenn die Zugriffsanweisung die Überprüfung nicht besteht, wird der Prozess beendet.

Diese Gegenmaßnahmen schützen die folgenden Windows APIs:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Legitime Anwendungen, die API-Abfang durchführen, können durch diese Gegenmaßnahmen erkannt werden und dazu führen, dass einige Anwendungen abstürzen. Beispiele hierfür sind Sicherheitssoftware und Anwendungskompatibilitäts-Shims.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Randomize memory allocations (Bottom-up ASLR)

### <a name="description"></a>Beschreibung

Randomize memory allocations (Bottom-up ASLR) fügt Verschiebungen Entropie hinzu, sodass ihr Standort randomisiert ist und daher weniger vorhersehbar ist. Für diese Gegenmaßnahmen muss die obligatorische ASLR wirksam werden.

Die Größe des 32-Bit-Adressraums stellt praktische Einschränkungen für die Entropie, die hinzugefügt werden kann, und daher erschweren 64-Bit-Anwendungen es einem Angreifer, einen Speicherort im Arbeitsspeicher zu erraten.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die meisten Anwendungen, die mit der obligatorischen ASLR (Rebasing) kompatibel sind, sind auch mit der anderen Entropie von Bottom-up ASLR kompatibel. Einige Anwendungen haben möglicherweise Probleme beim Abschneiden von Zeigern, wenn sie lokale Zeiger in 32-Bit-Variablen speichern (eine Basisadresse unter 4 GB erwartet), und daher mit der Option für hohe Entropie (die deaktiviert werden kann) nicht kompatibel ist.

### <a name="configuration-options"></a>Konfigurationsoptionen

Verwenden Sie keine hohe **Entropie** – mit dieser Option wird die Verwendung von ASLR mit hoher Entropie deaktiviert, wodurch der Bottom-up-Zuordnung für 64-Bit-Anwendungen 24 Bit Entropie (1 TB Varianz) hinzufügt werden.

> [!Note]
> **Randomize memory allocations (Bottom-up ASLR)** has no audit mode.

## <a name="simulate-execution-simexec"></a>Simulieren der Ausführung (SimExec)

### <a name="description"></a>Beschreibung

Die Simulationsausführung (SimExec) ist nur für 32-Bit-Anwendungen eine Gegenmaßnahmen. Dadurch wird überprüft, ob Anrufe an vertrauliche APIs wieder zu legitimen Anruferfunktionen zurückkehren. Dazu werden Aufrufe von vertraulichen APIs abgefangen und anschließend die Ausführung dieser APIs simuliert, indem die codierten Anweisungen für die Assemblysprache nach der RET-Anweisung gesucht werden, die an den Aufrufer zurückzukehren ist. Anschließend wird diese Funktion überprüft und rückwärts im Arbeitsspeicher nach der vorherigen CALL-Anweisung geschritten, um festzustellen, ob die Funktion und die CALL-Anweisung übereinstimmen und dass die RET nicht abgefangen wurde.

Die apIs, die von dieser Gegenmaßnahmen abgefangen werden, sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Wenn ein ROP-Gadget erkannt wird, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die API-Abfang durchführen, insbesondere Sicherheitssoftware, können kompatibilitätsprobleme mit dieser Gegenmaßnahmen verursachen.

Diese Gegenmaßnahmen sind mit der Arbitrary Code Guard-Gegenmaßnahmen nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-api-invocation-callercheck"></a>Überprüfen des API-Aufrufs (CallerCheck)

### <a name="description"></a>Beschreibung

Validate API invocation (CallerCheck) ist eine Gegenmaßnahmen für ROP-Techniken (Return-Oriented Programming), die überprüfen, ob vertrauliche APIs von einem gültigen Aufrufer aufgerufen wurden. Diese Risikominderung überprüft die übergebene Rückgabeadresse und zerlegt dann heuristisch rückwärts, um einen Anruf über der Rückgabeadresse zu finden, um zu ermitteln, ob das Anrufziel mit dem an die Funktion übergebenen Parameter entspricht.

Die apIs, die von dieser Gegenmaßnahmen abgefangen werden, sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Wenn ein ROP-Gadget erkannt wird, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die API-Abfang durchführen, insbesondere Sicherheitssoftware, können kompatibilitätsprobleme mit dieser Gegenmaßnahmen verursachen.

Diese Gegenmaßnahmen sind mit der Arbitrary Code Guard-Gegenmaßnahmen nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-exception-chains-sehop"></a>Überprüfen von Ausnahmeketten (SEHOP)

### <a name="description"></a>Beschreibung

Validate exception chains (SEHOP) is a mitigation against the *Structured Exception Handler (SEH) overwrite exploitation* technique. [Strukturierte Ausnahmebehandlung](https://docs.microsoft.com/windows/win32/debug/structured-exception-handling) ist der Prozess, mit dem eine Anwendung eine bestimmte Ausnahme behandeln kann. Ausnahmehandler werden verkettet, sodass ein Ausnahmehandler, der eine bestimmte Ausnahme nicht behandeln möchte, an den nächsten Ausnahmehandler in der Kette übergeben werden kann, bis er sich entscheidet, diese zu behandeln. Da die Liste des Handlers dynamisch ist, wird sie auf dem Stapel gespeichert. Ein Angreifer kann eine Sicherheitslücke beim Stapelüberlauf verwenden, um dann den Ausnahmehandler mit einem Zeiger auf den Code der Wahl des Angreifers zu überschreiben.

Diese Risikominderung basiert auf dem Entwurf von SEH, wobei jeder SEH-Eintrag sowohl einen Zeiger auf den Ausnahmehandler als auch einen Zeiger auf den nächsten Handler in der Ausnahmekette enthält. Diese Risikominderung wird vom Ausnahmesponser aufgerufen, der die SEH-Kette überprüft, wenn eine Ausnahme aufgerufen wird. Es überprüft, dass:

- Alle Ausnahmeketteneinträge befinden sich innerhalb der Stapelgrenzen
- Alle Ausnahmedatensätze werden ausgerichtet
- Keine Ausnahmehandlerzeiger zeigen auf den Stapel
- Es gibt keine Rückwärtszeiger
- Die Ausnahmekette endet bei einem bekannten endgültigen Ausnahmehandler

Wenn diese Überprüfungen fehlschlagen, wird die Ausnahmebehandlung abgebrochen, und die Ausnahme wird nicht behandelt.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Kompatibilitätsprobleme mit SEHOP sind relativ selten. Es ist ungewöhnlich, dass eine Anwendung von einer Beschädigung der Ausnahmekette abhängig ist. Einige Anwendungen sind jedoch von den subtilen Änderungen des Timings betroffen, die sich möglicherweise als Racebedingung manifestieren, die einen latenten Multithreadingfehler in der Anwendung zeigt.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Validate exception chains (SEHOP)** has no audit mode.

## <a name="validate-handle-usage"></a>Überprüfen der Verarbeitung der Verwendung

### <a name="description"></a>Beschreibung

*Bei der Überprüfung der Verwendung* von Handle handelt es sich um eine Risikominderung, die den Schutz vor angreifern mithilfe eines vorhandenen Handles für den Zugriff auf ein geschütztes Objekt unterstützt. Ein [Handle](https://docs.microsoft.com/windows/win32/sysinfo/handles-and-objects) ist ein Verweis auf ein geschütztes Objekt. Wenn Anwendungscode auf ein ungültiges Handle verweist, könnte dies darauf hinweisen, dass ein Gegner versucht, ein zuvor aufgezeichnetes Handle zu verwenden (welche Anwendungsreferenzzählung jedoch nicht bekannt ist). Wenn die Anwendung versucht, ein ungültiges Objekt zu verwenden, statt einfach null zurück zu geben, wird von der Anwendung eine Ausnahme ausgelöst (STATUS_INVALID_HANDLE).

Diese Risikominderung wird automatisch auf Windows Store angewendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die Verweise nicht genau nachverfolgen und diese Vorgänge nicht in Ausnahmehandler umschließen, werden potenziell von dieser Risikominderung betroffen sein.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Die Überprüfung der Verwendung der** Verarbeitung hat keinen Überwachungsmodus.

## <a name="validate-heap-integrity"></a>Überprüfen der Heapintegrität

### <a name="description"></a>Beschreibung

Die Überprüfung der Heapintegritätsminderung erhöht die Schutzebene von Heapminderungen in Windows, indem die Anwendung beendet wird, wenn eine Heapbeschädigung erkannt wird.  Die Gegenmaßnahmen umfassen:

- Verhindern, dass ein HEAP-Handle frei wird
- Durchführen einer weiteren Überprüfung für erweiterte Blockkopfzeilen für Heapzuordnungen
- Überprüfen, ob Heapzuordnungen noch nicht als in-Use gekennzeichnet sind
- Hinzufügen von Schutzseiten zu großen Zuordnungen, Heapsegmenten und Untersegmenten über einer Mindestgröße

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Gegenmaßnahmen werden bereits standardmäßig für 64-Bit-Anwendungen und für 32-Bit-Anwendungen angewendet, die Windows Vista oder höher zielen. Ältere Anwendungen aus Windows XP oder früheren Versionen sind am stärksten gefährdet, kompatibilitätsprobleme sind jedoch selten.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Die Überprüfung der Heapintegrität** hat keinen Überwachungsmodus.

## <a name="validate-image-dependency-integrity"></a>Überprüfen der Bildabhängigkeitsintegrität

### <a name="description"></a>Beschreibung

Die *Überprüfung der Imageabhängigkeitsminderung* schützt vor Angriffen, die versuchen, Code durch dlls zu ersetzen, die statisch durch Windows verknüpft sind. Die Technik der DLL-Ansage missbraucht den Suchmechanismus des Ladeprogrammes, um schädlichen Code zu injizieren, der verwendet werden kann, um schadhafter Code in einem erhöhten Kontext ausgeführt zu werden. Wenn der Ladevorgang eine Windows signierte Binärdatei lädt und dann alle dlls lädt, von denen die Binärdatei abhängt, werden diese Binärdateien überprüft, um sicherzustellen, dass sie auch digital als binäre Windows sind. Wenn die Signaturüberprüfung nicht möglich ist, wird die DLL nicht geladen, und es wird eine Ausnahme ausgelöst, und der Status STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Kompatibilitätsprobleme sind ungewöhnlich. Anwendungen, die darauf angewiesen sind, Windows Binärdateien durch lokale private Versionen zu ersetzen, sind betroffen, und es besteht auch ein geringes Risiko, dass in Multithreadanwendungen subtile Zeitfehler angezeigt werden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-stack-integrity-stackpivot"></a>Überprüfen der Stapelintegrität (StackPivot)

### <a name="description"></a>Beschreibung

Die Überprüfung der Stapelintegrität *(StackPivot)* schützt vor dem StackPivot-Angriff, einem ROP-Angriff, bei dem ein Angreifer einen gefälschten Stapel im Heapspeicher erstellt, und trickst die Anwendung dann dazu, in den gefälschten Stapel zurück zu kehren, der den Ausführungsfluss steuert.

Diese Risikominderung fängt Windows APIs ab und überprüft den Wert des Stapelzeigers. Wenn die Adresse des Stapelzeigers nicht zwischen dem unteren und oberen Rand des Stapels fällt, wird ein Ereignis aufgezeichnet, und wenn nicht im Überwachungsmodus, wird der Prozess beendet.

Die apIs, die von dieser Gegenmaßnahmen abgefangen werden, sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die gefälschte Stapel verwenden, werden betroffen sein, und es besteht auch ein geringes Risiko, dass in Multithreadanwendungen subtile Zeitfehler angezeigt werden.
Anwendungen, die API-Abfang durchführen, insbesondere Sicherheitssoftware, können kompatibilitätsprobleme mit dieser Gegenmaßnahmen verursachen.

Diese Gegenmaßnahmen sind mit der Arbitrary Code Guard-Gegenmaßnahmen nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachung** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe von Advanced Hunting in [Microsoft Defender for Endpoint angezeigt werden.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)
