---
title: Referenz zum Exploit-Schutz
keywords: Gegenmaßnahmen, Sicherheitsanfälligkeiten, Sicherheitsanfälligkeit Gegenmaßnahme, Sicherheitsrisiko, Sicherheitsrisiken, emet
description: Details zur Funktionsweise des Exploit-Schutzes in Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: b8d1abcc7f204b2d393729bc63b7b2b3ab53fbbd
ms.sourcegitcommit: 4886457c0d4248407bddec56425dba50bb60d9c4
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/03/2021
ms.locfileid: "53290185"
---
# <a name="exploit-protection-reference"></a>Exploit-Schutz -Referenz

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Gilt für:**
- [Microsoft Defender für Endpunkt](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Möchten Sie Microsoft Defender für Endpunkt erleben? [Registrieren Sie sich für eine kostenlose Testversion](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit-Schutz bietet erweiterte Schutzmaßnahmen für Anwendungen, die die IT-Pro anwenden können, nachdem der Entwickler die Software kompiliert und verteilt hat.

Dieser Artikel hilft Ihnen zu verstehen, wie Der Exploit-Schutz sowohl auf Der Richtlinienebene als auch auf der Ebene der einzelnen Gegenmaßnahmen funktioniert, um Ihnen zu helfen, Exploit-Schutz-Richtlinien erfolgreich zu erstellen und anzuwenden.

## <a name="how-mitigations-are-applied"></a>Anwenden von Gegenmaßnahmen

Exploit-Schutz-Gegenmaßnahmen werden pro Anwendung angewendet.

Gegenmaßnahmen werden über einen Registrierungseintrag für jedes Programm konfiguriert, für das Sie Schutzmaßnahmen konfigurieren. Diese Einstellungen werden im **MitigationOptions-Registrierungseintrag** für jedes Programm gespeichert (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Sie werden wirksam, wenn Sie das Programm neu starten, und bleiben wirksam, bis Sie es ändern und das Programm erneut starten.

> [!IMPORTANT]
> Mit den Ausführungsoptionen für Bilddateien können Sie nur einen Dateinamen oder Pfad und keine Versionsnummer, Architektur oder andere Unterscheidungszeichen angeben. Achten Sie darauf, die Gegenmaßnahmen auf Apps mit eindeutigen Namen oder Pfaden anzuwenden, und wenden Sie sie nur auf Geräten an, auf denen Sie diese Version und diese Architektur der Anwendung getestet haben.

Wenn Sie Exploit-Schutz-Gegenmaßnahmen mithilfe einer XML-Konfigurationsdatei über PowerShell, Gruppenrichtlinie oder MDM konfigurieren, werden bei der Verarbeitung dieser XML-Konfigurationsdatei einzelne Registrierungseinstellungen für Sie konfiguriert.

Wenn die Richtlinie zum Verteilen der XML-Datei nicht mehr erzwungen wird, werden die von dieser XML-Konfigurationsdatei bereitgestellten Einstellungen nicht automatisch entfernt. Um Exploit-Schutz-Einstellungen zu entfernen, exportieren Sie die XML-Konfiguration von einem sauberen Windows 10 Gerät, und stellen Sie diese neue XML-Datei bereit. Alternativ stellt Microsoft eine XML-Datei als Teil der Windows-Sicherheit Baselines zum Zurücksetzen von Exploit-Schutz-Einstellungen bereit.

Um Exploit-Schutz-Einstellungen mithilfe von PowerShell zurückzusetzen, können Sie den folgenden Befehl verwenden:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Nachfolgend finden Sie die mit den Windows-Sicherheit Baselines verteilten EP-reset.xml:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Referenz zur Risikominderung

In den folgenden Abschnitten werden die Von den einzelnen Exploit-Schutz-Gegenmaßnahmen bereitgestellten Schutzmaßnahmen, die Kompatibilitätsüberlegungen für die Risikominderung und die verfügbaren Konfigurationsoptionen beschrieben.

## <a name="arbitrary-code-guard"></a>Beliebiger Codeschutz

### <a name="description"></a>Beschreibung

Beliebiger Codeschutz schützt vor böswilligen Angreifern, die den Code ihrer Wahl durch eine Speichersicherheitssicherheit in den Arbeitsspeicher laden und diesen Code ausführen können.

Arbitrary Code Guard schützt eine Anwendung davor, dynamisch generierten Code auszuführen (Code, der nicht geladen wird, z. B. von der Exe selbst oder einer DLL). Arbitrary Code Guard verhindert, dass Speicher als ausführbare Datei markiert wird. Wenn eine Anwendung versucht, [Speicher zuzuweisen,](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)überprüfen wir die Schutzflags. (Speicher kann mit Lese-, Schreib- und/oder Ausführungsschutzflags zugewiesen werden.) Wenn die Zuordnung versucht, [](/windows/win32/memory/memory-protection-constants) das Execute-Schutzkennzeichen einzuschließen, schlägt die Speicherzuweisung fehl und gibt einen Fehlercode zurück (STATUS_DYNAMIC_CODE_BLOCKED). Wenn eine Anwendung versucht, [die Schutzkennzeichen des Speichers](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) zu ändern, der bereits zugewiesen wurde und das Ausführungsschutzkennzeichen enthält, schlägt die Berechtigungsänderung fehl und gibt einen Fehlercode zurück (STATUS_DYNAMIC_CODE_BLOCKED). [](/windows/win32/memory/memory-protection-constants)

Indem verhindert wird, dass das *Execute-Flag* festgelegt wird, kann das Feature zur Verhinderung der Datenausführung von Windows 10 dann vor dem Anweisungszeiger schützen, der auf diesen Speicher festgelegt wird und diesen Code ausführt.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Arbitrary Code Guard verhindert die Zuweisung von Arbeitsspeicher als ausführbare Datei, was ein Kompatibilitätsproblem mit Ansätzen wie Just-in-Time (JIT)-Compilern darstellt. Die meisten modernen Browser kompilieren beispielsweise JavaScript in systemeigenen Code, um die Leistung zu optimieren. Um diese Gegenmaßnahme zu unterstützen, müssen sie neu erkannt werden, um die JIT-Kompilierung außerhalb des geschützten Prozesses zu verschieben. Andere Anwendungen, deren Entwurf dynamisch Code aus Skripts oder anderen Zwischensprachen generiert, sind mit dieser Gegenmaßnahme ähnlich inkompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Thread-Opt-Out zulassen** – Sie können die Gegenmaßnahme so konfigurieren, dass ein einzelner Thread diesen Schutz abwählt. Der Entwickler muss die Anwendung mit Dem Bewusstsein für diese Gegenmaßnahme geschrieben und die [**SetThreadInformation-API**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) aufgerufen haben, wobei der *ThreadInformation-Parameter* auf **ThreadDynamicCodePolicy** festgelegt ist, um dynamischen Code in diesem Thread ausführen zu dürfen.

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="block-low-integrity-images"></a>Bilder mit niedriger Integrität blockieren

### <a name="description"></a>Beschreibung

Das Blockieren von Images mit niedriger Integrität verhindert, dass die Anwendung nicht vertrauenswürdige Dateien lädt, in der Regel, weil sie aus einem Sandkastenbrowser aus dem Internet heruntergeladen wurden.

Diese Gegenmaßnahme blockiert das Laden von Bildern, wenn das Bild über einen Zugriffssteuerungseintrag (Access Control Entry, ACE) verfügt, der Zugriff auf Low IL-Prozesse gewährt und nicht über eine Vertrauensbezeichnungs-ACE verfügt. Es wird vom Speicher-Manager implementiert, wodurch verhindert wird, dass die Datei im Arbeitsspeicher zugeordnet wird. Wenn eine Anwendung versucht, ein Bild mit niedriger Integrität zuzuordnen, wird ein STATUS_ACCESS_DENIED Fehler ausgelöst. Ausführliche Informationen zur Funktionsweise von Integritätsstufen finden Sie unter ["Obligatorische Integritätskontrolle".](/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Das Blockieren von Images mit niedriger Integrität verhindert, dass die Anwendung Dateien lädt, die aus dem Internet heruntergeladen wurden. Wenn ihr Anwendungsworkflow das Laden von heruntergeladenen Bildern erfordert, sollten Sie sicherstellen, dass sie von einem Prozess mit höherer Vertrauensebene heruntergeladen oder explizit neu bezeichnet werden, um diese Gegenmaßnahme anzuwenden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="block-remote-images"></a>Remoteimages blockieren

### <a name="description"></a>Beschreibung

Durch das Blockieren von Remoteimages kann verhindert werden, dass die Anwendung Dateien lädt, die auf einem Remotegerät gehostet werden, z. B. eine UNC-Freigabe. Das Blockieren von Remoteimages schützt vor dem Laden von Binärdateien in den Arbeitsspeicher, die sich auf einem externen Gerät befinden, das vom Angreifer gesteuert wird.

Durch diese Gegenmaßnahme wird das Laden von Bildern blockiert, wenn festgestellt wird, dass sich das Bild auf einem Remotegerät befindet. Es wird vom Speicher-Manager implementiert, wodurch verhindert wird, dass die Datei im Arbeitsspeicher zugeordnet wird. Wenn eine Anwendung versucht, eine Remotedatei zuzuordnen, wird ein STATUS_ACCESS_DENIED Fehler ausgelöst.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Das Blockieren von Remoteimages verhindert, dass die Anwendung Bilder von Remotegeräten lädt. Wenn Ihre Anwendung Dateien oder Plug-Ins von Remotegeräten lädt, ist sie nicht mit dieser Gegenmaßnahme kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="block-untrusted-fonts"></a>Nicht vertrauenswürdige Schriftarten blockieren

### <a name="description"></a>Beschreibung

Das Blockieren nicht vertrauenswürdiger Schriftarten verringert das Risiko eines Fehlers bei der Schriftartenparsierung, der dazu führt, dass der Angreifer Code auf dem Gerät ausführen kann. Nur Schriftarten, die im Verzeichnis "windows\fonts" installiert sind, werden zur Verarbeitung durch GDI geladen.

Diese Gegenmaßnahme wird in GDI implementiert, wodurch der Speicherort der Datei überprüft wird. Wenn sich die Datei nicht im Verzeichnis der Systemschriftarten befindet, wird die Schriftart nicht für die Analyse geladen, und dieser Aufruf schlägt fehl.

Diese Gegenmaßnahme wird zusätzlich zu der integrierten Gegenmaßnahme in Windows 10 1607 und höher bereitgestellt, wodurch die Schriftarten analyse aus dem Kernel und in einen Benutzermodus-App-Container verschoben wird. Jeder Exploit, der auf der Schriftartenparsierung basiert, geschieht daher in einem sandkastenbasierten und isolierten Kontext, wodurch das Risiko erheblich reduziert wird. Ausführliche Informationen zu dieser Risikominderung finden Sie im Blog ["Härtung Windows 10 mit Zero-Day Exploit-Gegenmaßnahmen."](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die häufigste Verwendung von Schriftarten außerhalb des Systemschriftartenverzeichnisses ist die Verwendung von [Webschriftarten.](/typography/fonts/font-faq#web) Moderne Browser, z. B. Microsoft Edge, verwenden DirectWrite anstelle von GDI und sind nicht betroffen. Ältere Browser wie Internet Explorer 11 (und der IE-Modus im neuen Microsoft Edge) können jedoch betroffen sein, insbesondere bei Anwendungen wie Office 365, die Schriftart-Glyphen zum Anzeigen der Benutzeroberfläche verwenden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="code-integrity-guard"></a>Codeintegritätsschutz

### <a name="description"></a>Beschreibung

Code Integrity Guard stellt sicher, dass alle in einen Prozess geladenen Binärdateien von Microsoft digital signiert werden. Code Integrity Guard enthält [WHQL-Signaturen](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), die die Ausführung von WHQL-genehmigten Treibern innerhalb des Prozesses ermöglichen.

Diese Gegenmaßnahme wird im Speicher-Manager implementiert, wodurch verhindert wird, dass die Binärdatei dem Arbeitsspeicher zugeordnet wird. Wenn Sie versuchen, eine Binärdatei zu laden, die nicht von Microsoft signiert ist, gibt der Speicher-Manager den Fehler STATUS_INVALID_IMAGE_HASH zurück. Durch das Blockieren auf Speicher-Manager-Ebene wird verhindert, dass sowohl vom Prozess geladene Binärdateien als auch Binärdateien in den Prozess eingefügt werden.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Gegenmaßnahme blockiert speziell alle Binärdateien, die nicht von Microsoft signiert sind. Daher ist sie mit den meisten Drittanbietersoftware nicht kompatibel, es sei denn, diese Software wird vom Microsoft Store verteilt (und digital signiert), und die Option zum Laden von Bildern, die vom Microsoft Store signiert wurden, ist ausgewählt.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Lassen Sie auch das Laden von Bildern zu,** die von Microsoft Store signiert wurden. Anwendungen, die vom Microsoft Store verteilt werden, werden vom Microsoft Store digital signiert, und durch Hinzufügen dieser Konfiguration können Binärdateien, die den Store-Zertifizierungsprozess durchlaufen haben, von der Anwendung geladen werden.

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="control-flow-guard-cfg"></a>Ablaufsteuerungsschutz (Control Flow Guard, CFG)

### <a name="description"></a>Beschreibung

Der Ablaufsteuerungsschutz (Control Flow Guard, CFG) verringert das Risiko, dass Angreifer Speicherbeschädigungsschwachstellen verwenden, indem sie indirekte Funktionsaufrufe schützen. Ein Angreifer kann beispielsweise eine Pufferüberlauf-Sicherheitslücke verwenden, um Speicher mit einem Funktionszeiger zu überschreiben und diesen Funktionszeiger durch einen Zeiger auf ausführbaren Code ihrer Wahl zu ersetzen (der möglicherweise auch in das Programm eingefügt wurde).

Diese Gegenmaßnahme wird bereitgestellt, indem zur Kompilierzeit eine weitere Überprüfung eingefügt wird. Vor jedem indirekten Funktionsaufruf werden weitere Anweisungen hinzugefügt, die überprüfen, ob das Ziel ein gültiges Aufrufziel ist, bevor es aufgerufen wird. Wenn das Ziel kein gültiges Anrufziel ist, wird die Anwendung beendet. Daher können nur Anwendungen, die mit CFG-Unterstützung kompiliert wurden, von dieser Gegenmaßnahme profitieren.

Die Überprüfung auf ein gültiges Ziel wird vom Windows Kernel bereitgestellt. Wenn ausführbare Dateien geladen werden, werden die Metadaten für indirekte Aufrufziele zum Ladezeitpunkt extrahiert und als gültige Aufrufziele markiert. Darüber hinaus werden diese Speicherspeicherorte auch als gültige Aufrufziele gekennzeichnet, wenn Speicher zugewiesen und als ausführbare Datei (z. B. für generierten Code) markiert wird, um Mechanismen wie die JIT-Kompilierung zu unterstützen.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Da Anwendungen kompiliert werden müssen, um CFG zu unterstützen, deklarieren sie implizit ihre Kompatibilität damit. Die meisten Anwendungen sollten daher mit aktivierter Gegenmaßnahme funktionieren. Da diese Überprüfungen in der Binärdatei kompiliert werden, können Sie die Konfiguration nur anwenden, um Überprüfungen im Windows Kernel zu deaktivieren. Mit anderen Worten, die Gegenmaßnahme ist standardmäßig aktiviert, Aber Sie können den Windows Kernel so konfigurieren, dass immer "Ja" zurückgegeben wird, wenn Sie später feststellen, dass ein Kompatibilitätsproblem vorliegt, das der Anwendungsentwickler beim Testen nicht erkannt hat, was selten sein sollte.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Verwenden Sie strict CFG** – Im strikten Modus müssen alle binären Dateien, die in den Prozess geladen werden, für Control Flow Guard kompiliert werden (oder keinen ausführbaren Code enthalten , z. B. Ressourcen-DLL-Dateien), um geladen zu werden.

> [!Note]
> **Der Ablaufsteuerungsschutz** verfügt über keinen Überwachungsmodus. Binärdateien werden mit aktivierter Gegenmaßnahme kompiliert.

## <a name="data-execution-prevention-dep"></a>Datenausführungsverhinderung (DATA Execution Prevention, DEP)

### <a name="description"></a>Beschreibung

Die Datenausführungsverhinderung (Data Execution Prevention, DEP) verhindert, dass Speicher ausgeführt wird, der nicht explizit als ausführbare Datei zugeordnet wurde. DEP schützt vor einem Angreifer, der bösartigen Code in den Prozess einfügt, z. B. durch einen Pufferüberlauf, und führt dann diesen Code aus.

Wenn Sie versuchen, den Anweisungszeiger auf eine Speicheradresse festzulegen, die nicht als ausführbare Datei gekennzeichnet ist, löst der Prozessor eine Ausnahme aus (Allgemeine Schutzverletzung), wodurch die Anwendung abstürzt.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Für alle ausführbaren Dateien x64, ARM und ARM-64 ist DEP standardmäßig aktiviert und kann nicht deaktiviert werden. Da eine Anwendung nie ohne DEP ausgeführt wurde, wird die Kompatibilität vorausgesetzt.

Für alle x86-Binärdateien (32-Bit) ist DEP standardmäßig aktiviert, DEP kann jedoch pro Prozess deaktiviert werden. Einige ältere Anwendungen, in der Regel Anwendungen, die vor Windows XP SP2 entwickelt wurden, sind möglicherweise nicht mit DEP kompatibel. Solche Anwendungen generieren in der Regel Code dynamisch (z. B. JIT-Kompilierung) oder verknüpfen ältere Bibliotheken (z. B. ältere Versionen von ATL), die dynamisch Code generieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

**AKTIVIEREN DER ATL-Thunk-Emulation** – Mit dieser Konfigurationsoption wird die ATL-Thunk-Emulation deaktiviert. ATL, die ActiveX Vorlagenbibliothek, ist so klein und schnell wie möglich konzipiert. Um die binäre Größe zu reduzieren, würde sie eine Technik namens *"Schlägern"* verwenden. Thunking wird in der Regel für die Interaktion zwischen 32-Bit- und 16-Bit-Anwendungen betrachtet, aber es gibt hier keine 16-Bit-Komponenten für ATL. Um die binäre Größe zu optimieren, speichert ATL stattdessen Computercode im Arbeitsspeicher, der nicht wortbündig ausgerichtet ist (wodurch eine kleinere Binärdatei erstellt wird), und ruft diesen Code dann direkt auf. ATL-Komponenten, die mit Visual Studio 7.1 oder früher (Visual Studio 2003) kompiliert wurden, weisen diesen Speicher nicht als ausführbare Datei zu – die Thunk-Emulation behebt dieses Kompatibilitätsproblem. Anwendungen mit einem binären Erweiterungsmodell (z. B. Internet Explorer 11) müssen häufig die ATL-Thunk-Emulation aktiviert haben.

## <a name="disable-extension-points"></a>Deaktivieren von Erweiterungspunkten

### <a name="description"></a>Beschreibung

Diese Gegenmaßnahme deaktiviert verschiedene Erweiterungspunkte für eine Anwendung, die verwendet werden können, um Persistenz herzustellen oder Rechte von schädlichen Inhalten zu erhöhen.

Dies umfasst Folgendes:

- **AppInit-DLLs:** Jedes Mal, wenn ein Prozess gestartet wird, lädt das System die angegebene DLL in den Kontext des neu gestarteten Prozesses, bevor die Einstiegspunktfunktion aufgerufen wird. [Details zu AppInit-DLLs finden Sie hier.](/windows/win32/winmsg/about-window-classes#application-global-classes) Wenn diese Gegenmaßnahme angewendet wird, werden AppInit-DLLs nicht geladen. Ab Windows 7 müssen AppInit-DLLs digital signiert werden, [wie hier beschrieben.](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) Darüber hinaus werden, beginnend mit Windows 8, AppInit-DLLs nicht geladen, wenn SecureBoot aktiviert ist, [wie hier beschrieben.](/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **Legacy-IMEs** : Mit einem Eingabemethoden-Editor (Input Method Editor, IME) kann ein Benutzer Text in einer Sprache eingeben, die mehr Zeichen enthält, als auf einer Tastatur dargestellt werden können. Drittanbieter können IMEs erstellen. Ein böswilliger IME kann Anmeldeinformationen oder andere vertrauliche Informationen aus dieser Eingabeerfassung abrufen. Einige IMEs, die als Legacy-IMEs bezeichnet werden, funktionieren nur für Windows Desktop-Apps und nicht für UWP-Apps. Diese Gegenmaßnahme verhindert auch, dass dieser ältere IME in die angegebene Windows Desktop-App geladen wird.
- **Windows Event Hooks** – Eine Anwendung kann die [SetWinEventHook-API](/windows/win32/api/winuser/nf-winuser-setwineventhook) aufrufen, um Interesse an einem Ereignis zu registrieren, das stattfindet. Eine DLL wird angegeben und kann in den Prozess eingefügt werden. Diese Gegenmaßnahme erzwingt, dass der Hook im Registrierungsprozess bereitgestellt wird, anstatt innerhalb des Prozesses über eine eingefügte DLL ausgeführt zu werden.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die meisten dieser Erweiterungspunkte werden relativ selten verwendet, sodass die Kompatibilitätsauswirkungen in der Regel gering sind, insbesondere auf einzelner Anwendungsebene. Die einzige Überlegung ist, ob Benutzer Legacy-IMEs von Drittanbietern verwenden, die nicht mit der geschützten Anwendung funktionieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

Es gibt keine Konfigurationsoptionen für diese Gegenmaßnahme.

> [!Note]
> **Das Deaktivieren von Erweiterungspunkten** hat keinen Überwachungsmodus.

## <a name="disable-win32k-system-calls"></a>Win32k-Systemaufrufe deaktivieren

### <a name="description"></a>Beschreibung

Win32k.sys bietet eine breite Angriffsfläche für einen Angreifer. Als Kernelmoduskomponente wird sie häufig als Escapevektor für Sandkastenanwendungen verwendet. Diese Gegenmaßnahme verhindert Aufrufe von win32k.sys, indem verhindert wird, dass sich ein Thread selbst in einen GUI-Thread konvertiert, der dann Zugriff zum Aufrufen von Win32k-Funktionen erhält. Ein Thread ist beim Erstellen nicht GUI, wird aber beim ersten Aufruf an win32k.sys oder durch einen API-Aufruf von [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread)konvertiert.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Gegenmaßnahme ist für Prozesse vorgesehen, bei denen es sich um dedizierte Nicht-UI-Prozesse handelt. Beispielsweise verwenden viele moderne Browser Prozessisolation und integrieren Nicht-UI-Prozesse. Jede Anwendung, die eine GUI mit einem einzigen Prozess anzeigt, wird von dieser Gegenmaßnahme betroffen sein.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="do-not-allow-child-processes"></a>Untergeordnete Prozesse nicht zulassen

### <a name="description"></a>Beschreibung

Diese Risikominderung verhindert, dass eine Anwendung neue untergeordnete Anwendungen erstellt. Ein gängiges Verfahren, das von Angreifern verwendet wird, ist das Initiieren eines vertrauenswürdigen Prozesses auf dem Gerät mit böswilligen Eingaben (ein "Leben vom Land"-Angriff), bei dem häufig eine andere Anwendung auf dem Gerät gestartet werden muss. Wenn es keine berechtigten Gründe gibt, warum eine Anwendung einen untergeordneten Prozess starten würde, entschärft diese Risikominderung diesen potenziellen Angriffsvektor. Die Gegenmaßnahme wird angewendet, indem eine Eigenschaft für das Prozesstoken festgelegt wird, wodurch das Erstellen eines Tokens für den untergeordneten Prozess mit der Fehlermeldung STATUS_CHILD_PROCESS_BLOCKED blockiert wird.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Wenn Ihre Anwendung aus irgendeinem Grund untergeordnete Anwendungen startet, z. B. unterstützen von Links, die einen Browser oder einen externen Browser starten, oder die andere Dienstprogramme auf dem Computer starten, wird diese Funktionalität unterbrochen, wenn diese Gegenmaßnahme angewendet wird.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="export-address-filtering"></a>Exportieren der Adressfilterung

### <a name="description"></a>Beschreibung

Die Exportadressfilterung (Export Address Filtering, EAF) verringert das Risiko, dass schädlicher Code die Exportadresstabelle aller geladenen Module ansieht, um Module zu finden, die nützliche APIs für ihren Angriff enthalten. Dies ist eine gängige Taktik, die von Shellcode verwendet wird. Um das Risiko eines solchen Angriffs zu mindern, schützt diese Maßnahme drei häufig angegriffene Module:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

Die Gegenmaßnahme schützt die Speicherseite im [Exportverzeichnis, das auf die [Exportadresstabelle](/windows/win32/debug/pe-format#export-address-table)verweist. Auf diese Speicherseite wird der [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) Schutz angewendet. Wenn jemand versucht, auf diesen Speicher zuzugreifen, wird ein STATUS_GUARD_PAGE_VIOLATION generiert. Die Gegenmaßnahme behandelt diese Ausnahme, und wenn die Zugriffsanweisung die Überprüfung nicht besteht, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Dieser Ausgleich ist in erster Linie ein Problem für Anwendungen wie Debugger, Sandkastenanwendungen, Anwendungen mit DRM oder Anwendungen, die Antidebuggingtechnologie implementieren.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Überprüfen des Zugriffs auf Module, die häufig von Exploits missbraucht werden** – diese Option, auch als EAF+ bezeichnet, fügt Schutz für andere häufig angegriffene Module hinzu:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Durch die Aktivierung von EAF+ wird außerdem der PAGE_GUARD Schutz der Seite hinzugefügt, die den "MZ"-Header enthält, die ersten beiden Bytes des [DOS-Headers in einer PE-Datei.](/windows/win32/debug/pe-format#ms-dos-stub-image-only)Dies ist ein weiterer Aspekt bekannter Speicherinhalte, nach denen Shellcode suchen kann, um Module zu identifizieren, die möglicherweise für den Arbeitsspeicher von Interesse sind.

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="force-randomization-for-images-mandatory-aslr"></a>Erzwingen von zufälligen Abbildern (obligatorisches ASLR)

### <a name="description"></a>Beschreibung

Die Zufälligkeit des Adressraumlayouts (Address Space Layout Randomization, ASLR) verringert das Risiko, dass ein Angreifer sein Wissen über das Speicherlayout des Systems nutzt, um Code auszuführen, der bereits im Prozessspeicher vorhanden und bereits als ausführbare Datei gekennzeichnet ist. Dadurch kann das Risiko eines Angreifers durch Techniken wie Return-to-libc-Angriffe verringert werden, bei denen der Angreifer den Kontext festlegt und dann die Absenderadresse ändert, um vorhandenen Code mit Kontext auszuführen, der dem Zweck des Angreifers entspricht.

Eine obligatorische ASLR erzwingt eine Neubasis aller DLLs innerhalb des Prozesses. Ein Entwickler kann ASLR mit der Option ["/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) linker" aktivieren, und diese Gegenmaßnahme hat die gleiche Auswirkung.

Wenn der Speicher-Manager das Image dem Prozess zuweist, wird die obligatorische ASLR DLLs und EXEs, die sich nicht für ASLR entschieden haben, forcieren. Beachten Sie jedoch, dass diese Neubasis keine Entropie aufweist und daher an einer vorhersagbaren Stelle im Arbeitsspeicher platziert werden kann. Für die neubasierte und zufällige Position von Binärdateien sollte diese Gegenmaßnahme mit [randomisierten Speicherzuweisungen (Bottom-up ASLR)](#randomize-memory-allocations-bottom-up-aslr)kombiniert werden.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Kompatibilitätsauswirkungen von ASLR sind in der Regel auf ältere Anwendungen beschränkt, die mit Compilern erstellt wurden, die Annahmen über die Basisadresse einer Binärdatei gemacht oder Basisverlagerungsinformationen entfernt haben. Dies kann zu unvorhersehbaren Fehlern führen, wenn der Ausführungsfluss versucht, zur erwarteten Position zu springen und nicht zum tatsächlichen Speicherort im Arbeitsspeicher.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Keine entfernten Bilder zulassen** – diese Option blockiert das Laden von Bildern, deren Verlagerungsinformationen entfernt wurden. Das Windows PE-Dateiformat enthält absolute Adressen, und der Compiler generiert auch eine [Basis-Verlagerungstabelle, die das Ladeprogramm verwenden kann, um alle relativen Speicherverweise und deren Offset zu finden, sodass sie aktualisiert werden können, wenn die Binärdatei nicht an der bevorzugten Basisadresse geladen wird. Einige ältere Anwendungen entfernen diese Informationen in Produktionsbuilds, und daher können diese Binärdateien nicht neu erstellt werden. Dieser Ausgleich verhindert, dass solche Binärdateien geladen werden (anstatt sie an ihrer bevorzugten Basisadresse laden zu können).

> [!Note]
> **Die Zufallszurücknahme für Bilder (obligatorische ASLR)** hat keinen Überwachungsmodus.

## <a name="import-address-filtering-iaf"></a>Import-Adressfilterung (IAF)

### <a name="description"></a>Beschreibung

Die Minderung der Importadressfilterung (Import Address Filtering, IAF) trägt dazu bei, das Risiko zu minimieren, dass ein Angreifer den Steuerungsfluss einer Anwendung ändert, indem die Importadresstabelle (Import Address Table, IAT) so geändert wird, dass beim Aufrufen dieser Funktion beliebiger Code der Wahl des Angreifers umgeleitet wird. Ein Angreifer könnte diesen Ansatz verwenden, um die Kontrolle zu übernehmen oder Aufrufe vertraulicher APIs abzufangen, zu überprüfen und potenziell zu blockieren.

Auf die Speicherseiten für alle geschützten APIs wird der [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) Schutz angewendet. Wenn jemand versucht, auf diesen Speicher zuzugreifen, wird ein STATUS_GUARD_PAGE_VIOLATION generiert. Die Gegenmaßnahme behandelt diese Ausnahme, und wenn die Zugriffsanweisung die Überprüfung nicht besteht, wird der Prozess beendet.

Diese Maßnahme schützt die folgenden Windows APIs:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Seriöse Anwendungen, die API-Interception ausführen, werden möglicherweise von dieser Gegenmaßnahme erkannt und führen dazu, dass einige Anwendungen abstürzten. Beispiele hierfür sind Sicherheitssoftware- und Anwendungskompatibilitäts-Shims.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Zufällige Speicherzuweisungen (Bottom-up ASLR)

### <a name="description"></a>Beschreibung

Randomize memory allocations (Bottom-up ASLR) adds entropy to verlagern, so their location is randomized and therefore less predictable. Diese Risikominderung setzt voraus, dass die obligatorische ASLR wirksam wird.

Die Größe des 32-Bit-Adressraums stellt praktische Einschränkungen für die Entropie dar, die hinzugefügt werden kann. Daher machen 64-Bit-Anwendungen es angreifern schwieriger, einen Speicherort im Arbeitsspeicher zu erraten.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Die meisten Anwendungen, die mit der obligatorischen ASLR (Rebasing) kompatibel sind, sind auch mit der anderen Entropie von Bottom-up ASLR kompatibel. Einige Anwendungen haben möglicherweise Probleme beim Abschneiden von Zeigern, wenn sie lokale Zeiger in 32-Bit-Variablen speichern (wobei eine Basisadresse unter 4 GB erwartet wird) und daher mit der Option "Hohe Entropie" (die deaktiviert werden kann) nicht kompatibel ist.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Verwenden Sie keine hohe Entropie** – diese Option deaktiviert die Verwendung von ASLR mit hoher Entropie, die 24 Bit Entropie (1 TB Varianz) in die Bottom-Up-Zuordnung für 64-Bit-Anwendungen einfügt.

> [!Note]
> **Randomize memory allocations (Bottom-up ASLR)** has no audit mode.

## <a name="simulate-execution-simexec"></a>Simulieren der Ausführung (SimExec)

### <a name="description"></a>Beschreibung

Die Simulation der Ausführung (SimExec) ist nur für 32-Bit-Anwendungen eine Maßnahme. Dies hilft zu überprüfen, ob Aufrufe vertraulicher APIs zu legitimen Aufruferfunktionen zurückkehren. Dazu werden Aufrufe vertraulicher APIs abgefangen und dann die Ausführung dieser APIs simuliert, indem die Anweisungen für die codierte Assemblysprache durchlaufen werden, um nach der RET-Anweisung zu suchen, die an den Aufrufer zurückgegeben werden sollte. Anschließend wird diese Funktion überprüft und rückwärts im Arbeitsspeicher nach der vorherigen CALL-Anweisung gesucht, um zu ermitteln, ob die Funktion und die CALL-Anweisung übereinstimmen und ob das RET nicht abgefangen wurde.

Die von dieser Gegenmaßnahme abgefangenen APIs sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Wenn ein ROP-Gerät erkannt wird, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die API-Interception durchführen, insbesondere Sicherheitssoftware, können Kompatibilitätsprobleme mit dieser Lösung verursachen.

Diese Gegenmaßnahme ist mit der Gegenmaßnahme für beliebigen Code Guard nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="validate-api-invocation-callercheck"></a>Überprüfen des API-Aufrufs (CallerCheck)

### <a name="description"></a>Beschreibung

Der Validate-API-Aufruf (CallerCheck) ist eine Gegenmaßnahme für Return-Oriented Programming (ROP)-Techniken, die überprüfen, ob vertrauliche APIs von einem gültigen Aufrufer aufgerufen wurden. Diese Gegenmaßnahme prüft die übergebene Absenderadresse und zerlegt dann heuristisch rückwärts, um einen Aufruf über der Absenderadresse zu finden, um zu ermitteln, ob das Aufrufziel mit dem parameter übereinstimmt, der an die Funktion übergeben wurde.

Die von dieser Gegenmaßnahme abgefangenen APIs sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Wenn ein ROP-Gerät erkannt wird, wird der Prozess beendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die API-Interception durchführen, insbesondere Sicherheitssoftware, können Kompatibilitätsprobleme mit dieser Lösung verursachen.

Diese Gegenmaßnahme ist mit der Gegenmaßnahme für beliebigen Code Guard nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="validate-exception-chains-sehop"></a>Überprüfen von Ausnahmeketten (SEHOP)

### <a name="description"></a>Beschreibung

Die Überprüfung von Ausnahmeketten (SEHOP) ist eine Gegenmaßnahme gegen das Verfahren zum Überschreiben der Nutzung durch *strukturierte Ausnahmehandler (Structured Exception Handler, SEH).* [Strukturierte Ausnahmebehandlung](/windows/win32/debug/structured-exception-handling) ist der Prozess, mit dem eine Anwendung eine bestimmte Ausnahme behandeln kann. Ausnahmehandler werden miteinander verkettet, sodass ein Ausnahmehandler, der sich entscheidet, eine bestimmte Ausnahme nicht zu behandeln, an den nächsten Ausnahmehandler in der Kette übergeben werden kann, bis er die Behandlung beschließt. Da die Liste des Handlers dynamisch ist, wird sie im Stapel gespeichert. Ein Angreifer kann eine Stack Overflow-Sicherheitslücke verwenden, um dann den Ausnahmehandler mit einem Zeiger auf den Code der Wahl des Angreifers zu überschreiben.

Diese Gegenmaßnahme basiert auf dem Entwurf von SEH, wobei jeder SEH-Eintrag sowohl einen Zeiger auf den Ausnahmehandler als auch einen Zeiger auf den nächsten Handler in der Ausnahmekette enthält. Diese Gegenmaßnahme wird vom Ausnahme-Dispatcher aufgerufen, der die SEH-Kette überprüft, wenn eine Ausnahme aufgerufen wird. Es wird Folgendes überprüft:

- Alle Ausnahmekettendatensätze befinden sich innerhalb der Stapelgrenzen
- Alle Ausnahmedatensätze werden ausgerichtet
- Keine Ausnahmehandlerzeiger zeigen auf den Stapel
- Es gibt keine Rückwärtszeiger
- Die Ausnahmekette endet bei einem bekannten endgültigen Ausnahmehandler.

Wenn diese Überprüfungen fehlschlagen, wird die Ausnahmebehandlung abgebrochen, und die Ausnahme wird nicht behandelt.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Kompatibilitätsprobleme mit SEHOP sind relativ selten. Es ist ungewöhnlich, dass eine Anwendung eine Abhängigkeit von der Beschädigung der Ausnahmekette übernimmt. Einige Anwendungen sind jedoch von den geringfügigen Änderungen des Timings betroffen, die sich als Racebedingung manifestieren können, die einen latenten Multithreadingfehler in der Anwendung anzeigt.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Validate exception chains (SEHOP)** has no audit mode.

## <a name="validate-handle-usage"></a>Überprüfen der Handleverwendung

### <a name="description"></a>Beschreibung

Die Überprüfung der *Handhabungsnutzung* ist eine Maßnahme, die vor einem Angreifer schützt, der ein vorhandenes Handle verwendet, um auf ein geschütztes Objekt zuzugreifen. Ein [Handle](/windows/win32/sysinfo/handles-and-objects) ist ein Verweis auf ein geschütztes Objekt. Wenn Anwendungscode auf ein ungültiges Handle verweist, könnte dies darauf hinweisen, dass ein Angreifer versucht, ein zuvor aufgezeichnetes Handle zu verwenden (die Anwendungsreferenzzählung wäre jedoch nicht bekannt). Wenn die Anwendung versucht, ein ungültiges Objekt zu verwenden, anstatt einfach NULL zurückzugeben, löst die Anwendung eine Ausnahme aus (STATUS_INVALID_HANDLE).

Diese Gegenmaßnahme wird automatisch auf Windows Store Anwendungen angewendet.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die Verweise nicht genau nachverfolgen und diese Vorgänge nicht in Ausnahmehandler umschließen, sind möglicherweise von dieser Gegenmaßnahme betroffen.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Überprüfen der Handle-Verwendung** hat keinen Überwachungsmodus.

## <a name="validate-heap-integrity"></a>Überprüfen der Heapintegrität

### <a name="description"></a>Beschreibung

Die Überprüfung der *Heapintegritätsminderung* erhöht die Schutzebene von Heap-Gegenmaßnahmen in Windows, indem die Anwendung beendet wird, wenn eine Heap-Beschädigung erkannt wird. Die Gegenmaßnahmen umfassen:

- Verhindern, dass ein HEAP-Handle freigegeben wird
- Durchführen einer weiteren Überprüfung für erweiterte Blockheader für Heap-Zuordnungen
- Überprüfen, ob Heap-Zuordnungen noch nicht als verwendet gekennzeichnet sind
- Hinzufügen von Schutzseiten zu großen Zuordnungen, Heap-Segmenten und Untersegmenten über einer Mindestgröße

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Diese Gegenmaßnahme wird bereits standardmäßig für 64-Bit-Anwendungen und für 32-Bit-Anwendungen angewendet, die auf Windows Vista oder höher abzielen. Ältere Anwendungen von Windows XP oder früheren Versionen sind am stärksten gefährdet, kompatibilitätsprobleme sind jedoch selten.

### <a name="configuration-options"></a>Konfigurationsoptionen

> [!Note]
> **Überprüfen der Heapintegrität** hat keinen Überwachungsmodus.

## <a name="validate-image-dependency-integrity"></a>Überprüfen der Integrität von Imageabhängigkeiten

### <a name="description"></a>Beschreibung

Die Überprüfung der *Risikominderung von Bildabhängigkeiten* schützt vor Angriffen, die versuchen, Code durch DLL-Dateien zu ersetzen, die statisch durch Windows Binärdateien verknüpft sind. Die Technik der DLL-Generierung missbraucht den Suchmechanismus des Ladeprogramms, um bösartigen Code einzufügen, der verwendet werden kann, um bösartigen Code in einem Kontext mit erhöhten Rechten auszuführen. Wenn das Ladeprogramm eine Windows signierte Binärdatei lädt und dann alle DLL-Dateien lädt, von denen die Binärdatei abhängt, werden diese Binärdateien überprüft, um sicherzustellen, dass sie auch digital als Windows Binärdatei signiert sind. Wenn die Signaturüberprüfung fehlschlägt, wird die DLL nicht geladen und löst eine Ausnahme aus, wodurch der Status STATUS_INVALID_IMAGE_HASH zurückgegeben wird.

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Kompatibilitätsprobleme sind ungewöhnlich. Anwendungen, die darauf angewiesen sind, Windows Binärdateien durch lokale private Versionen zu ersetzen, sind betroffen, und es besteht auch ein geringes Risiko, dass geringfügige Timing-Fehler in Multithread-Anwendungen angezeigt werden.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.

## <a name="validate-stack-integrity-stackpivot"></a>Überprüfen der Stapelintegrität (StackPivot)

### <a name="description"></a>Beschreibung

Die Überprüfung der *Stapelintegrität (StackPivot)* schützt vor dem StackPivot-Angriff, einem ROP-Angriff, bei dem ein Angreifer einen gefälschten Stapel im Heap-Speicher erstellt, und trickst die Anwendung dann dazu, in den gefälschten Stapel zurückzukehren, der den Ausführungsfluss steuert.

Diese Gegenmaßnahme fängt viele Windows APIs ab und überprüft den Wert des Stapelzeigers. Wenn die Adresse des Stapelzeigers nicht zwischen dem unteren und oberen Rand des Stapels liegt, wird ein Ereignis aufgezeichnet, und wenn sich dieser nicht im Überwachungsmodus befindet, wird der Prozess beendet.

Die von dieser Gegenmaßnahme abgefangenen APIs sind:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Überlegungen zur Kompatibilität

Anwendungen, die gefälschte Stapel verwenden, sind betroffen, und es besteht auch ein geringes Risiko, dass geringfügige Timing-Fehler in Multithreadanwendungen angezeigt werden.
Anwendungen, die API-Interception durchführen, insbesondere Sicherheitssoftware, können Kompatibilitätsprobleme mit dieser Lösung verursachen.

Diese Gegenmaßnahme ist mit der Gegenmaßnahme für beliebigen Code Guard nicht kompatibel.

### <a name="configuration-options"></a>Konfigurationsoptionen

**Nur Überwachen** – Sie können diese Risikominderung im Überwachungsmodus aktivieren, um die potenziellen Kompatibilitätsauswirkungen auf eine Anwendung zu messen. Überwachungsereignisse können dann entweder in der Ereignisanzeige oder mithilfe der erweiterten Suche in [Microsoft Defender für Endpunkt](/microsoft-365/security/defender/advanced-hunting-overview)angezeigt werden.
